package vtgraphql

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"strings"
	"time"
)

type Recording struct {
	ID               string   `json:"id,omitempty"`
	StartDateTime    int64    `json:"startDateTime"`
	StopDateTime     int64    `json:"stopDateTime"`
	Security         Security `json:"security,omitempty"`
	ApplicationID    string   `json:"applicationId,omitempty"`
	Status           string   `json:"status,omitempty"`
	MediaSourceID    string   `json:"source,omitempty"`
	CreatedDateTime  string   `json:"createdDateTime,omitempty"`  // should be int64
	ModifiedDateTime string   `json:"modifiedDateTime,omitempty"` // should be int64

	Assets AssetList `json:"assets,omitempty"`
}

type Asset struct {
	ID          string                 `json:"id,omitempty"`
	Name        string                 `json:"name, omitempty"`
	Description string                 `json:"description, omitempty"`
	ContentType string                 `json:"contentType, omitempty"`
	AssetType   string                 `json:"assetType, omitempty"`
	SignedURI   string                 `json:"uri,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	ContainerId string                 `json:"containerId,omitempty"`

	CreatedDateTime  string `json:"createdDateTime,omitempty"`  // should be int64
	ModifiedDateTime string `json:"modifiedDateTime,omitempty"` // should be int64
	CreatedBy        string `json:"createdBy,omitempty"`
	ModifiedBy       string `json:"modifiedBy,omitempty"`
}

func (this *Recording) Validate() bool {
	return true
}

// []Asset
type AssetList struct {
	Records []Asset `json:"records, omitempty"`
}

type Security struct {
	Global bool `json:"global"`
}

func (r Recording) String() string {
	pretty, _ := json.MarshalIndent(&r, "", "\t")
	return string(pretty)
}
func (a Asset) String() string {
	pretty, _ := json.MarshalIndent(&a, "", "\t")
	return string(pretty)
}

/** ==========================
  GetRecording
  ========================== **/
type GetRecordingResponse struct {
	Data TemporalDataObjectStruct `json:"data"`
}

// really a recording
type TemporalDataObjectStruct struct {
	TemporalDataObject *Recording `json:"temporalDataObject"`
}

// ideally this should be generated by walking the structure and concatenate the names -- using the json tag
const GetRecordingRequest = "{\"query\":\"{temporalDataObject(id: \\\"%s\\\") {id startDateTime stopDateTime source applicationId    status    createdDateTime    modifiedDateTime    assets { records {        id       name        contentType       assetType     uri       metadata       createdDateTime       modifiedDateTime}}}}\"}"

/** finicky JSON unmarshaling, have to allocate the struct first so it can use as a template to unmarshal correspondingly */
func createARecordingResponseTemplateForUnmarshal() *TemporalDataObjectStruct {
	// here we'll need to deserialze rawBody into recording
	g := &TemporalDataObjectStruct{
		TemporalDataObject: &Recording{
			Assets: AssetList{
				Records: make([]Asset, 1, 8),
			},
		},
	}
	g.TemporalDataObject.Assets.Records[0].Metadata = make(map[string]interface{})
	return g
}

func (this *APIClient) GetRecording(ctx context.Context, recordingID string) (*Recording, error) {
	if recordingID == "" {
		return nil, ErrorInvalidRecordingID
	}

	RecordingQueryString := fmt.Sprintf(GetRecordingRequest, recordingID)
	log.Println(RecordingQueryString)
	rawBody, err := this.doRequestWithBody(ctx, strings.NewReader(RecordingQueryString))
	if err != nil {
		return nil, err
	}
	g := createARecordingResponseTemplateForUnmarshal()

	err = json.Unmarshal(*rawBody, g)
	if err != nil {
		log.Printf("Unmashalling got err=%v\n[2]RawBody=%s\n", err, string(*rawBody))
		return nil, err
	}
	/* DEBUGGING purpose */
	rec := g.TemporalDataObject
	if err != nil {
		return nil, err
	}
	assets := rec.Assets.Records
	if err != nil {
		log.Printf("Got error from getting assets?:", err)
		return rec, nil
	}
	log.Printf("Recording Id = %s, #of Assets=%d\n", rec.ID, len(assets))
	for i, a := range assets {
		log.Printf("Asset [%d] = %v\n", i, a)
	}

	return g.TemporalDataObject, err
}

/** =============
  CreateAsset
  ============= */
type CreateAssetResponse struct {
	CreateAsset *Asset `json:"createAsset"`
}

func (this *APIClient) CreateAsset(ctx context.Context, recordingID string, data io.Reader, asset Asset) (*Asset, error) {
	m, err := MarshalMetadataAsJson(asset.Metadata)

	mutationString := fmt.Sprintf("mutation {createAsset(input:  {containerId: \"%s\", assetType:\"%s\", contentType:\"%s\",  metadata: %s })"+
		" {id name contentType description createdDateTime modifiedDateTime createdBy modifiedBy metadata containerId uri assetType}}",
		recordingID,
		asset.AssetType,
		asset.ContentType,
		m) //string(m))
	log.Printf("MUTATION STRING:>>>>\n%s\n<<<<\n", mutationString)
	extraParams := map[string]string{
		"query": mutationString}
	fileName := fmt.Sprintf("asset-%s-%v", asset.AssetType, time.Now())
	rawResponse, err := this.doMutiPartRequest(ctx, extraParams, "file", fileName, data)

	if err != nil {
		return nil, err
	}
	log.Printf("RawResponse from createAsset=%s", string(*rawResponse))
	createAssetResponse := &CreateAssetResponse{CreateAsset: &Asset{Metadata: make(map[string]interface{})}}
	err = json.Unmarshal(*rawResponse, createAssetResponse)
	if err != nil {
		return nil, err
	}
	return createAssetResponse.CreateAsset, err
}
